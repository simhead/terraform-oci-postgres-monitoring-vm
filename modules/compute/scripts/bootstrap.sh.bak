#!/bin/bash

# Variables
USER_NAME=opc
USER_HOME=/home/${USER_NAME}
APP_NAME=oci-pmm-vm
DEV_TOOLS_HOME=${USER_HOME}/${APP_NAME}
INSTALL_LOG_FILE_NAME=install-${APP_NAME}.log
INSTALL_LOG_FILE=${USER_HOME}/${INSTALL_LOG_FILE_NAME}
SSHD_BANNER_FILE=/etc/ssh/sshd-banner
SSHD_CONFIG_FILE=/etc/ssh/sshd_config
UPDATE_SCRIPT_FILE=update-kit.sh
UPDATE_SCRIPT_WITH_PATH=/usr/local/bin/${UPDATE_SCRIPT_FILE}
UPDATE_SCRIPT_LOG_FILE=${USER_HOME}/${UPDATE_SCRIPT_FILE}.log
DEVICE_PATH="/dev/sdb"
MOUNT_POINT="/mnt/pmm-data"
PMM_LINK="${PMM_SHELL_LINK}"

INSTALLATION_IN_PROGRESS="
    #################################################################################################
    #                                           WARNING!                                            #
    #   OCI PMM VM Installation is still in progress.                                      #
    #   To check the progress of the installation run -> tail -f ${INSTALL_LOG_FILE_NAME}           #
    #################################################################################################
"

USAGE_INFO="
    =================================================================================================
                                        OCI PMM VM Usage
                                        ===================
    This instance has OCI PMM VM such as CLI, Terraform, Ansible, Docker, PMM

    To update OCI PMM VM to the latest version, run the following command: ${UPDATE_SCRIPT_FILE}

    You could use Instance Principal authentication to use the dev tools.

    For running CLI, type the following to get more help: oci --help
    =================================================================================================
"

start=`date +%s`

# yum install packages are listed here. This same list is used for update too
PACKAGES_TO_INSTALL=(
    python36-oci-cli 
    terraform 
    terraform-provider-oci 
    oci-ansible-collection 
    python36-oci-sdk.x86_64 
    oracle-golang-release-el7
    golang 
    go-oci-sdk 
    java-oci-sdk
    git-1.8.3.1-23.el7_8.x86_64
    rh-ruby27
    oci-ruby-sdk
    oracle-nodejs-release-el7
    oci-dotnet-sdk.noarch
    oci-powershell-modules
    netcat
    postgresql
)

# Log file
sudo -u ${USER_NAME} touch ${INSTALL_LOG_FILE}
sudo -u ${USER_NAME} chmod +w ${INSTALL_LOG_FILE}

# Sending all stdout and stderr to log file
exec >> ${INSTALL_LOG_FILE}
exec 2>&1

echo "Installing OCI PMM VM"
echo "------------------------"

echo "Creating sshd banner"
sudo touch ${SSHD_BANNER_FILE}
sudo echo "${INSTALLATION_IN_PROGRESS}" > ${SSHD_BANNER_FILE}
sudo echo "${USAGE_INFO}" >> ${SSHD_BANNER_FILE}
sudo echo "Banner ${SSHD_BANNER_FILE}" >> ${SSHD_CONFIG_FILE}
sudo systemctl restart sshd.service

####### mount pmm data volume #########
# Check if the device exists before proceeding
if [ ! -b "$DEVICE_PATH" ]; then
    echo "ERROR: Device $DEVICE_PATH not found. Exiting."
    exit 1
fi

# Check if the device has already been formatted (only format once)
if ! sudo blkid "$DEVICE_PATH" | grep -q 'ext4'; then
    echo "Formatting device $DEVICE_PATH..."
    sudo mkfs -t ext4 -F "$DEVICE_PATH"
else
    echo "Device $DEVICE_PATH already formatted."
fi

# Create the directory where the volume will be mounted
sudo mkdir -p "$MOUNT_POINT"

# Get the unique identifier (UUID) for stable mounting
UUID=$(sudo blkid -s UUID -o value "$DEVICE_PATH")

# Add the mount entry to /etc/fstab for persistence across reboots
# 'nofail' option ensures the system still boots if the volume temporarily fails to attach.
FSTAB_ENTRY="UUID=$UUID $MOUNT_POINT ext4 defaults,nofail 0 2"

if ! grep -q "$MOUNT_POINT" /etc/fstab; then
    echo "Adding entry to /etc/fstab..."
    echo "$FSTAB_ENTRY" | sudo tee -a /etc/fstab
fi

# Mount all defined filesystems (includes the new entry)
sudo mount -a

sudo chmod 777 "$MOUNT_POINT"

echo "Volume $DEVICE_PATH mounted successfully at $MOUNT_POINT and configured for persistence."
####### mount pmm data volume - End #########   

####### Installing yum packages #########
sudo yum install -y yum-utils
# Add the official Docker stable repository using the tool provided by yum-utils
sudo yum-config-manager --add-repo https://download.docker.com/linux/centos/docker-ce.repo

echo "installing packages ${PACKAGES_TO_INSTALL[*]}"

sudo yum-config-manager --enable ol7_developer ol7_developer_EPEL && echo "#################### Successfully installed ol7_developer yum packages #####################"

# sudo yum -y install ${PACKAGES_TO_INSTALL[@]} && echo "#################### Successfully installed all yum packages #####################"

sudo yum -y install ${PACKAGES_TO_INSTALL[*]} && echo "#################### Successfully installed all yum packages #####################"

sudo yum -y install --enablerepo=ol7_developer_nodejs10 --enablerepo=ol7_developer oci-typescript-sdk && echo "#################### Successfully installed typescript #####################"

####### Installing yum packages -End #########

####### Adding OCI Modules to Powershell #########

sudo -u ${USER_NAME} pwsh -c Register-PSRepository -Name LocalRepository -SourceLocation /usr/lib/dotnet/NuPkgs -InstallationPolicy Trusted
sudo -u ${USER_NAME} pwsh -c "Set-Variable -Name ProgressPreference -Value SilentlyContinue; Install-Module OCI.PSModules -Repository LocalRepository"
sudo -u ${USER_NAME} pwsh -c Uninstall-Module OCI.PSModules
sudo -u ${USER_NAME} pwsh -c Unregister-PSRepository -Name LocalRepository

####### Adding OCI Modules to Powershell -End #########

####### Adding environment variables #########
echo "Adding environment variable so terraform can be AuthN using instance principal"
sudo -u ${USER_NAME} echo 'export TF_VAR_auth=InstancePrincipal' >> ${USER_HOME}/.bashrc
sudo -u ${USER_NAME} echo "export TF_VAR_region=$(oci-metadata -g regionIdentifier --value-only)" >> ${USER_HOME}/.bashrc
sudo -u ${USER_NAME} echo "export TF_VAR_tenancy_ocid=$(oci-metadata -g tenancy_id --value-only)" >> ${USER_HOME}/.bashrc

echo "Adding environment variable so oci-cli can be AuthN using instance principal"
sudo -u ${USER_NAME} echo 'export OCI_CLI_AUTH=instance_principal' >> ${USER_HOME}/.bashrc

echo "Adding environment variable so ansible can be AuthN using instance principal"
sudo -u ${USER_NAME} echo 'export OCI_ANSIBLE_AUTH_TYPE=instance_principal' >> ${USER_HOME}/.bashrc

echo "Adding environment variable so powershell can be AuthN using instance principal"
sudo -u ${USER_NAME} echo 'export OCI_PS_AUTH="InstancePrincipal"' >> ${USER_HOME}/.bashrc

sudo -u ${USER_NAME} echo 'export GOPATH=/usr/share/gocode' >> ${USER_HOME}/.bashrc

echo "Adding environment variable so oci jars are in the classpath"
JAVASDK_VERSION=$(yum list java-oci-sdk | grep -o "[0-9].[0-9]\+.[0-9]\+" | head -1)
sudo -u ${USER_NAME} echo "export CLASSPATH=/usr/lib64/java-oci-sdk/lib/oci-java-sdk-full-${JAVASDK_VERSION}.jar:/usr/lib64/java-oci-sdk/third-party/lib/*" >> ${USER_HOME}/.bashrc

echo "Adding environment variable so ruby collections are properly set"
sudo -u ${USER_NAME} echo "source scl_source enable rh-ruby27" >> ${USER_HOME}/.bashrc
sudo -u ${USER_NAME} echo "export GEM_PATH=/usr/share/gems:'gem env gempath'" >> ${USER_HOME}/.bashrc
echo "Adding environment variable so dotnet collections are properly set"
sudo -u  ${USER_NAME} echo "source scl_source enable rh-dotnet31" >> ${USER_HOME}/.bashrc

echo "Adding environment variable so oci-cli can be AuthN using instance principal"
sudo echo 'export OCI_CLI_AUTH=instance_principal' >> /etc/bashrc

echo "Adding environment variable for SDK analytics"
sudo -u ${USER_NAME} echo 'export OCI_SDK_APPEND_USER_AGENT=Oracle-ORMDevTools' >> ${USER_HOME}/.bashrc

####### Adding environment variables - End #########

sudo yum install -y docker-ce docker-ce-cli containerd.io 
sudo systemctl start docker
sudo systemctl enable docker

# 1. Add the user to the docker group
echo "Adding user ${USER_NAME} to the docker group..."
sudo usermod -aG docker "${USER_NAME}"
echo "User added to docker group. Starting new shell to activate changes..."

sudo docker volume create pmm-data --driver local  --opt type=none  --opt device=/mnt/pmm-data --opt o=bind

# 2. Use 'exec su -l' to create a new login shell for the same user.
# This terminates the current script/shell process and replaces it with a new one.
# Crucially, the -l (login) flag ensures groups are re-evaluated.
# exec su -l "${USER_NAME}" -c 'curl -fsSL https://www.percona.com/get/pmm | /bin/bash'
su -l "${USER_NAME}" -c "curl -fsSL ${PMM_LINK} | /bin/bash"

sudo yum install -y https://repo.percona.com/yum/percona-release-latest.noarch.rpm
sudo percona-release enable pmm2-client

sudo yum install -y pmm2-client
####### Generating upgrade script #########
DOLLAR_SIGN="$"

echo "Creating update script"
echo "----------------------"
cat > ${UPDATE_SCRIPT_WITH_PATH} <<EOL
#!/bin/bash

PACKAGES_TO_UPDATE=(
    python36-oci-cli 
    terraform 
    terraform-provider-oci 
    oci-ansible-collection 
    python36-oci-sdk.x86_64 
    oracle-golang-release-el7
    golang 
    go-oci-sdk 
    java-oci-sdk
    git
    oci-ruby-sdk
    oracle-nodejs-release-el7
    --enablerepo=ol7_developer_nodejs10 --enablerepo=ol7_developer oci-typescript-sdk
    oci-dotnet-sdk.noarch
    oci-powershell-modules
    netcat
    postgresql
)

# Log file
sudo -u ${USER_NAME} touch ${UPDATE_SCRIPT_LOG_FILE}
sudo -u ${USER_NAME} chmod +w ${UPDATE_SCRIPT_LOG_FILE}

exec > >(tee ${UPDATE_SCRIPT_LOG_FILE})
exec 2>&1

echo "Updating OCI PMM VM"
echo "----------------------"

echo "Packages to update ${DOLLAR_SIGN}{PACKAGES_TO_UPDATE[@]}"
sudo yum -y install ${DOLLAR_SIGN}{PACKAGES_TO_UPDATE[@]} && echo "#################### Successfully updated all yum packages #####################"

echo "-----------------------------------"
echo "Updating OCI PMM VM is complete"

EOL
####### Generating upgrade script -End #########
echo "Update script creation complete"

sudo chmod +x ${UPDATE_SCRIPT_WITH_PATH}

end=`date +%s`

executionTime=$((end-start))

echo "--------------------------------------------------------------"
echo "Installation of OCI PMM VM is complete. (Took ${executionTime} seconds)"

sudo echo "${USAGE_INFO}" > ${SSHD_BANNER_FILE}

exec -l $SHELL


docker ps